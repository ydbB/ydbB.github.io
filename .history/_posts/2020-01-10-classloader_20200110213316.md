---
layout: post
tilel: 类加载的方式和双亲委派模型
---
问题23：类加载的过程，什么是双亲委派模型

Java 引入了字节码 和 JVM ，提供了 Java 语言跨平台的能力，理解类加载的过程是深入 Java 开发的前提。

### 典型回答

一般地将 Java 初始化分为三个步骤：加载，链接， 初始化。

* 加载，将 Java 字节码读取到 JVM 中，并映射为 JVM 认可的数据结构。如果 JVM 不认可数据结构，则会抛出ClassFormatError；
* 链接，将 加载好的数据结构，平滑装入转入 JVM 运行的的过程，可以分为以下三个阶段：
  * 验证，这是虚拟机安全的重要保障，JVM 需要校验字节信息是符合 Java 虚拟机规范的， 否则抛出 VerifyError，验证可以防止恶意的信息或者不规范信息危害 JVM 的行为；
  * 准备，创建类或者接口中的静态变量，并初始化静态变量的值，但是这里的“初始化”侧重于分配内存空间，与开发中的初始化不同；
  * 解析，这一步会将常量池中的符号引用转换为直接引用，
* 初始化，真正执行初始化的代码逻辑，包括静态字段的赋值，以及执行类定义内部静态初始化块内的逻辑。


Java 的双亲委派模型是指，当前类加载器在试图加载某个类型的时候，除非父加载器找不到相应的类型，否则尽量将这个任务代理给当前任务加载器的父加载器去做。避免了 Java 类型的重复加载。

### 考点分析

上面的回答是 Java 类加载的主要内容。

类加载也可以从开发和部署来考虑：
* 如果要真正理解双亲委派模型，需要理解 Java 中类加载器的架构和职责，至少要懂具体有哪些内建的类加载器，这些是我上面的回答里没有提到的；以及如何自定义类加载器？
* 从应用角度，解决某些类加载问题，例如我的 Java 程序启动较慢，有没有办法尽量减小 Java 类加载的开销？另外，需要注意的是，在 

### 知识扩展

从架构角度，一起来看看 Java 8 以前各种类加载器的结构，下面是三种 Oracle JDK 内建的类加载器。
* 启动类加载器（Bootstrap Class-Loader），加载 jre/lib 下面的 jar 文件，如 rt.jar。它是个超级公民，即使是在开启了 Security Manager 的时候，JDK 仍赋予了它加载的程序 AllPermission。
* 扩展类加载器（Extension or Ext Class-Loader），负责加载我们放到 jre/lib/ext/ 目录下面的 jar 包，这就是所谓的 extension 机制。该目录也可以通过设置 “java.ext.dirs”来覆盖。
* 应用类加载器（Application or App Class-Loader），就是加载我们最熟悉的 classpath 的内容。这里有一个容易混淆的概念，系统（System）类加载器，通常来说，其默认就是 JDK 内建的应用类加载器，但是它同样是可能修改的。

Java 类加载通常有三个特征：
* 双亲委派模型，但是并不是所有的类加载都遵守，比如加载用户自定义的类。Java 中 JNDI、JDBC、文件系统、Cipher 等很多方面，都是利用的这种机制，这种情况就不会用双亲委派模型去加载，而是利用所谓的上下文加载器。
* 可见性，子加载器可以访问父加载器加载的类型，反之则不行；
* 单一性，因为双亲模型子加载器可以访问父加载器加载的类型，所以不会在子加载器中重复加载。

谈到类加载器，就绕不开自定义类加载器，常见场景有：
* 实现进程内部隔离，类加载器用作不同命名空间，以提高类似容器，模块化的效果；
* 应用需要从不同数据源获取类加载信息；
* 需要自己操作字节码，动态修改或生成类型。

怎么提高 Java 启动速度？

Java 字节码编译，解释成机器码的过程都拖慢了 Java 启动的过程，因此可以利用下面的方法降低 Java 加载的开销，
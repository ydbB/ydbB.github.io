---
layout: post
title: JVM 区域划分，哪些区域可能导致 OutOfMemoryError?
subtitle: 是时候去拥抱新世界了！！！Lazy Bob !!!
---
谈谈 JVM 的内存划分，哪些区域可能会发生 OutOfMemoryError?

### 典型回答
JVM 可以分为一下几块：
* 程序计数器(PC): 在 JVM 每个线程都有自己的程序计数器，并且任何一段时间，一个线程只有一个方法在执行，也就是所谓的当前方法，程序计数器会存储线程的存储当前正在执行线程的 JVM 指令地址，或者如果正在指定本地方法，则是未指定值。  
* Java 虚拟机栈，早期也称为 Java 栈，每个线程创建时都会创建一个虚拟机栈，保存栈帧，对应 Java 方法调用。 栈帧中存储着局部变量表，操作数栈，动态链接，方法正常退出或异常退出的定义等。
* 堆，是 Java 内存管理的核心区域，存放 Java 对象实例。堆被所有线程共享，虚拟机启动时，我们可以指定 “Xmx”/"Xms" 指定最大堆的大小。
* 方法区，所有线程共享，存储所谓的元数据，例如：类结构信息，运行时常量池，字段，方法代码等。
* 运行时常量池，方法区的一部分，Java 常量池可以存储很多常量信息，如编译生成的各种字面量，还有在运行时决定的符号引用。
* 本地方法栈，与 Java 虚拟机栈相似，但是未本地 Java 方法服务。

### 考点分析
Java 内存的开篇，侧重：　　
* 分析广义上 JVM 内存结构/ Java 进程内存结构
* 谈到 JVM 内存模型，不可避免 OutOfMemoryError

### 知识扩展

Java 对象是不是都是在堆上建立呢？

有观点认为逃逸技术，JVM 可以在栈上分配对象，理论可行，但是取决于 JVM 设计者。Oracle HotSpot JVM 中并未这么做，所以可以明确所有对象都是在堆上建立的。

目前的很多资料都基于 JDK　７，但是　JDK　已经发生很多变更，Intern 字符串的缓存和静态变量曾经被分配在永久代,而永久代已经被元数据区取代,但是 Intern 字符串缓存和静态变量并不是被转移到了元数据区,而是直接被分配到堆上.

什么是 OOM 问题,它可能出现在哪些区域?

OOM 通俗来说就是 JVM 内存不够用了, 用 javadoc 的解释就是,没有空闲内存,并且垃圾回收器无法提供更多内存.

这里也隐含了 OOM 前, JVM 会进行垃圾回收.

从前面的数据区中,除了程序计数器,其他区域都可能会发生 OutOfMemoryError,原因如下:
* 堆内存不足是最为常见的一种,抛出 "java.lang.OutOfMemoryError:Java heap space”,原因多样,可能存在内存泄漏问题,可能堆大小不合适, JVM 来不及处理引用,导致堆积,内存无法释放.
* 而对于 Java 虚拟机栈和本地方法栈，这里要稍微复杂一点。如果我们写一段程序不断的进行递归调用，而且没有退出条件，就会导致不断地进行压栈。类似这种情况，JVM 实际会抛出 StackOverFlowError；当然，如果 JVM 试图去扩展栈空间的的时候失败，则会抛出 OutOfMemoryError。
* 老版的 JDK ,因为